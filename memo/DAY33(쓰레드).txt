
DAY33
컬렉션 프레임워크 -> 쓰레드


1. 컬렉션 프레임워크
	
1) List, Set, Map 인터페이스
	인터페이스의 멤버 : 추상메소드, 상수, + 디폴트 메소드, 스태틱 메소드, private 메소드
	List : 순서 보장, 중복값 허용o, 추가 삭제 수정 가능
		- ArrayList()
	Set  : 순서 없고, 중복값 허용x, 추가 삭제 가능, 수정 불가 (순서[인덱스]가 없기때문이다.)
		- HashSet()
	Map  : key-value 한쌍으로 관리된다. key 중복불가. / value 중복허용
		- HashMap()

2) Iterator : 반복자
	컬렉션에 저장된 데이터를 컬렉션 종류와 상관없이 동일한 방식으로 가져오기 위한 인터페이스이다.
	hasNext() : 가져올 객체가 있으면 true반환 없으면 false반환
	next() : 다음값을 가져오는 메소드
	iterator() : 컬렉션 객체를 Iterator타입으로 변환하는 메소드.
	
3) Entry
	
	Map 인터페이스에서 정의된 중첩 인터페이스
	Map에서 키와 값의 쌍을 표현할 수 있다.
	Map.Entry : 각 키-값 쌍을 나타내고 맵의 항목들을 쉽게 순회하고 조작할 수 있도록 도와준다.
	Map.Entry는 주로 entrySet() 메소드를 통해 사용된다.
	entrySet() : 맵의 Entry 객체로 구성된 Set을 반환하는 메소드
			키와 값의 쌍을 순회하고 조작할 수 있다.
----------------------------------------------------------------------------------------
2. 쓰레드 *(thread)

0) 쓰레드 알기 전 사전 지식
	- 프로그램(소프트웨어)
	특정 작업을 수행하는 명령어(소스코드)들의 모음
	메모리를 할당받지 않은 상태이므로 -> 꺼져있다.	

	- 프로세스
	실행중인 프로그램을 의미(ctrl shift esc : 작업관리자)
	프로세스는 프로그램을 실행시키기 위한 메모리 등의 자원과 쓰레드로 구성된다.
	즉, 하나의 프로세스는 하나 이상의 쓰레드를 가지고 있다.

+)컴퓨터 구성하는 3계층
	S/W  - 어플리케이션
	     - 시스템소프트웨어(Operating System,OS)

	H/W

	시스템 자원 : 프로그램을 실행시키기 위해 필요한 것을 운영체제(OS)를 통해 제공받아야한다.
		   이렇게 제공받는 것을 시스템 자원이라고 한다.
		   파일, signal, 기타 소프트웨어 등.
	하드웨어 자원 : CPU, 주기억장치, 보조기억장치, 입출력장치 등
	

1) 쓰레드
	하나의 프로세스 내에서 작업을 처리하는 흐름의 단위 = 작업을 처리하는 것 자체

	- 싱글쓰레드
	하나의 쓰레드가 작업을 마치면 프로그램을 종료하고,
	쓰레드를 하나만 가지고 있기 때문에 작업을 순차적으로 처리하므로 상대적으로 비효율적이다.(ex_은행창구 직원 1명, main메소드)
	쓰레드는 자원을 사용하는데 싱글쓰레드는 혼자서 자원을 사용하므로 동기화를 걱정할 필요가 없다.
	따라서 안정성이 높고 설계가 쉽다.

	- 멀티쓰레드
	메인쓰레드가 작업을 마치더라도 다른 쓰레드는 작업이 모두 끝나야만 프로그램이 종료된다.
	하나의 프로세스에서 여러 작업을 동시에 처리하는 것처럼 느껴지지만 사실은 각각의 쓰레드를 매우 빠른 속도로 
	실행시켜서 조금씩 처리한다.
	쓰레드 간 공유하는 자원이 있다면 문제가 발생할 수 있으며 이러한 문제를 동기화를 통해 해결한다.
	안정성이 떨어지고 설계가 어렵다.		




3. 멀티쓰레드
1) 멀티쓰레드 구현방법
   Thread 클래스 상속
   Runnable 인터페이스 구현

   -> run() 메소드에 쓰레드가 처리할 작업을 재정의한다(오버라이딩)
   -> start() 메소드로 쓰레드를 실행시킨다

+) Thread.currentThread().getName()
   현재 실행중인 쓰레드의 이름을 반환하는 기능
   어떤 쓰레드가 작업을 수행중인지 확인할 수 있다

Thread.currentThread()
   Thread 객체의 정적메소드, 호출 되는 시점의 현재 쓰레드를 참조
   현재 실행중인 쓰레드를 반환한다

getName()
   Thread 객체의 인스턴스 메소드, 해당 쓰레드의 이름을 반환

쓰레드이름
   디버깅할 때 어떤 쓰레드가 작업을 하는지 조사할 목적으로 주로 사용된다
   현재 코드를 어떤 쓰레드가 실행하는지 확인하려면 currentThread() 정적 메소드로 쓰레드 객체의 참조를 얻은 다음
   getName()메소드로 이름을 출력하면 된다

   메인 쓰레드 : main
   작업 쓰레드 : Thread-n의 이름을 가진다
      작업 쓰레드의 이름을 다른 이름으로 설정하고 싶다면 Thread클래스의 setName()메소드를 사용하면 된다
      thread.setName("쓰레드 이름");


2) 멀티쓰레드 관련 메소드
(1) run()
   쓰레드가 호출하는 메소드

(2) start()
   쓰레드를 실행시키며, run()메소드를 호출한다

(3) sleep(long millis)
   매개변수로 전달한 시간동안 쓰레드를 멈춘다

(4) join() join(long millis)
   현재 쓰레드의 작업을 멈추고 join을 사용한 쓰레드를 기다린다
   매개변수에 값을 전달하지 않으면 현재 쓰레드가 join을 사용한 쓰레드의 작업이 끝날때까지 기다린다
   매개변수에 값을 전달하면 해당 시간동안 기다렸다가 현재 쓰레드를 다시 실행한다
   보통 먼저 실행시킬 쓰레드에 사용한다
(5) wait()
   동기화된 영역에서만 사용가능
   쓰레드의 lock을 회수하여 다른 쓰레드에게 제어권을 넘겨주고 대기한다(대기중에는 lock을 얻을 수 없다)

(6) notify()
   동기화된 영역에서만 사용가능
   대기 중인 쓰레드 중 하나를 깨운다
   실행 가능한 상태로 바뀌는 것이지 lock을 넘겨주는 것이 아니다

3) 쓰레드 동작과정
   Thread 클래스 상속 또는 Runnable 인터페이스를 통해 run()메소드 구현
   쓰레드 객체 생성
   start() 메소드 호출
   쓰레드 실행
   쓰레드 종료

4) 쓰레드 상태
   쓰레드는 생성된 후부터 종료될 때까지 여러 상태를 가질 수 있다
   
   NEW      쓰레드가 생성되고 아직 START()가 호출되지 않은 상태
   RUNNABLE   실행중 또는 실행가능한 상태
   BLOCKED      동기화 블록에 의해서 일시정지된 상태(LOCK이 풀릴 때까지 기다리는 상태)
   WAITING,    쓰레드의 작업이 종료되지 않았지만 실행가능하지 않음(UNRUNNABEL) 일시 정지 상태,
   TIMED_WAITING    일시정지 시간이 지정된 경우를 의미함
   TERMINATED   쓰레드의 작업이 종료된 상태

   객체생성 -> start() 호출 -> 실행 -> 실행 대기 -> 실행 -> 실행완료
   NEW  -> RUNNABLE   -> RUNNING -> WIATING / BOLCKED / TIMED_WAITING -> RUNNING -> TERMINATED

   쓰레드에서 처리할 로직을 run()메소드에서 구현하고 Thread 클래스의 start()메소드를 이용해 실행
   -> 실행 대기 상태로 들어감(JVM의 스케줄링에 의해 실행할 수 있는 상태)
   -> 자바 프로그램은 JVM에 의해 실행되는 쓰레드가 결정되며 이것을 스케줄링이라고 한다


5) 동기화(Synchronized)
	A쓰레드와 B쓰레드가 작업을 진행할때 A가 사용중인 자원을 B가 사용하여 변경한다면
	A의 작업의도와 다르게 결과가 나타날 수 있다. 이런 것을 방지하기 위해
	하나의 자원을 여러 쓰레드가 동시에 접근하지 못하게 막는 것을 동기화라고 한다.

	- 동기화 영역 만들기
	synchronized(객체명) {...} : 동기화 블록
	일부 소스코드만 동기화를 걸어준다.	
	쓰레드는 지정된 객체의 lock을 얻어내며 해당 객체의 lock을 가진 쓰레드만
	동기화 블록에 접근이 가능하다.

	synchronized 리턴타입 메소드명(){...} : 동기화 메소드
	해당 메소드 전체에 동기화를 걸어준다.


6) Lock 
	쓰레드가 공유되는 자원을 사용할 때 생기는 문제를 동기화로 해결한다.
	이때 하나의 자원에 하나의 쓰레드만 접근하기 위해 사용하는 개념이다.

	자바의 모든 객체는 하나의 Lock을 가지고 있다.
	동기화된 영역을 쓰레드가 사용하기 위해서는 Lock을 획득해야만하고,
	동기화 영역을 벗어나면 Lock을 반납하고 다른 쓰레드가 Lock을 가져와 자원을 사용한다.



+) 교착상태(DeadLock)
	멀티 쓰레드 프로그래밍이나 멀티 쓰레드 환경(운영체제)에서 발생하는 대표적인 문제
	여러 쓰레드가 서로 자원(변수 등)을 점유한 상태에서 다른 쓰레드가 점유하고 있는 자원을 기다리며(wait()메소드)
	무한 대기 상태에 빠지는 비정상적인 상황을 의미함.


	- 교착상태 해결 방법
	=> 전체 쓰레드를 깨운다. 
	   모든 쓰레드를 깨워서 무한 대기를 중단시킨다.
	=> 특정 쓰레드 하나를 종료시킨다.
	   특정 쓰레드를 강제로 종료하여 자원 점유를 해제시킨다.

	- 교착상태가 발생하는 4가지 조건
	=> 상호배제 : 자원이 한번에 하나의 쓰레드만 사용할 수 있다.
	=> 점유대기 : 한 쓰레드가 자원을 점유한 상태에서 추가로 다른 자원을 요청하며 기다린다.
	=> 비선점 : 쓰레드가 점유한 자원을 빼앗을 수 없다.
	=> 순환대기 : 두 개 이상의 쓰레드가 자원을 순환적으로 대기한다.



- 교착상태 해결 전략(시험빈출)
   예방   교착상태가 발생하지 않도록 4가지 조건 중 최소 하나를 제거
   회피   교착상태가 발생할 수 있는 자원요청을 사전에 파악하여 허용여부결정
      -> 대표 알고리즘 : 은행가 알고리즘(Banker's Algorithm)
   탐지   교착상태 발생을 허용하고 발생시 탐지 후 처리
   회복   교착상태 탐지 후 특정 프로세스 종료 또는 자원회수로 해결

- 교착상태가 발생하는 4가지 조건(시험빈출)
   - 상호배제 : 자원이 한번에 하나의 쓰레드만 사용할 수 있다
   - 점유대기 : 한 쓰레드가 자원을 점유한 상태에서 추가로 다른 자원을 요청하며 대기한다
   - 비선점 : 쓰레드가 점유한 자원을 빼앗을 수 없다
   - 순환대기 : 두 개 이상의 쓰레드가 자원을 순환적으로 대기한다

7) 쓰레드 종료 방법

(1) 쓰레드 객체의 interrupt()를 사용하여 InterruptedException을 발생시켜 try~catch문으로 이동시킨다
   여기서 InterruptedException은 쓰레드를 대기 상태로 만드는 sleep(), wait(), join()등의 메소드를 사용한 곳에서 발생된다
   위의 메소드들에 예외처리하고 interrupt()를 통해 예외를 발생시키면 쓰레드의 흐름이 해당 메소드의 catch문으로 이동된다
   예외처리를 했다고 해서 강제 종료되는 것이 아니므로 catch문에서 쓰레드가 종료될 수 있는 코드를 작성하여 처리해야한다

(2) System.exit(0) 를 사용하면 전체 쓰레드가 종료된다(프로그램 종료)

(3) 쓰레드 객체를 대기상태로 만드는 메소드를 사용하지 않았을 경우 Thread.interrupted()를 사용하면 interrupt()의 사용여부를 boolean타입으로
   반환한다 이점을 이용하여 쓰레드의 흐름을 제어할 수 있다
   단, interrupted()를 한 번 사용하거나 예외처리로 catch문으로 이동하면 interrupted()는 다시 false를 반환한다

멘토씨리즈 교재 p464






	
